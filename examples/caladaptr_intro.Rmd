---
title: "Intro to caladaptR"
output:
  html_notebook:
    df_print: paged
---

```{css echo = FALSE}
h1 {
  font-weight: bold;
  color: darkolivegreen;
  border-top: 3px solid dimgrey;
  margin-top: 1em;
  padding-top: 0.5em;
}
h1.title {
  color: black;
  border: none;
}
h2 {
  font-weight: bold;
  font-size: 22px;
  color: dimgray;
}

h3 {
  font-weight: bold;
  font-size: 18px;
  color: black;
}

```

# About this R Notebook

R Notebooks are a 'flavor' of R markdown that combine plain text with R commands in code chunks. You can (and should!) edit them, and save it every few minutes like anything else!

If you're in RStudio, go ahead and *minimize the console window* (and maybe close the right-hand panes as well). You won't need it. When you run the R commands the *output appears below the code chunk*.

Keyboard shortcuts:
 - run the current line of R: *ctrl + enter*  
 - run everything in the current code chunk: *ctrl + shift + enter*  
 - insert a new code chunk: *ctrl + alt + i*  

# Setup

The following three lines will install any packages that will be needed below:

```{r load_pkgs, cache = TRUE}
pkgs_req <- c("remotes", "ggplot2", "dplyr", "tmap", "conflicted", "leaflet", "tidyr")
pkgs_missing <- pkgs_req[!(pkgs_req %in% installed.packages()[,"Package"])]
if (length(pkgs_missing)) install.packages(pkgs_missing, dependencies=TRUE)
```

Install caladaptr:

```{r}
# remotes::install_github("ucanr-igis/caladaptr")
```

Now we can load all the required libraries:

```{r library_all}
library(caladaptr, quietly = TRUE)
library(units, quietly = TRUE)
library(ggplot2, quietly = TRUE)
library(dplyr, quietly = TRUE)
library(conflicted, quietly = TRUE)
library(tidyr, quietly = TRUE)
library(tmap, quietly = TRUE)
library(lubridate, quietly = TRUE)
library(sf, quietly = TRUE)
```

The last setup task is to define your preferences when you're forced to use an ambiguous function name (i.e., a function that exists in more than one package). This is particularly needed with a few common generic functions from `dplyr`:

```{r set_conflicts}
conflict_prefer("filter", "dplyr", quiet = TRUE)
conflict_prefer("count", "dplyr", quiet = TRUE)
conflict_prefer("select", "dplyr", quiet = TRUE)
```

# Example #1: Get Projected Temperature for a Point

## Create the Cal-Adapt API Request

The first step in getting climate variables back is to create the Cal-Adapt API request object. This involves stringing together a series of functions together that specify the pieces of the request. The following constants can help you specify pieces of the request:

```{r view_constants, cache = TRUE}
## Available global change models
gcms

## Available emissions scenarios
scenarios

## Available climate variables
climvars

## Available temporal aggregation periods
periods
```
You can use these values as arguments to build up the API request:

```{r}
cap1 <- ca_loc_pt(coords = c(-121.4687, 38.5938)) %>%
  ca_gcm(gcms[1:4]) %>%
  ca_scenario(c("rcp45", "rcp85")) %>%
  ca_period("year") %>%
  ca_years(start = 2030, end = 2080) %>%
  ca_cvar(c("tasmax"))

cap1
```
To verify the location in an API request, you can plot it. (Note we still haven't fetched any climate data yet, this just shows you the location the request will ask for.)

```{r plot_cap1}
plot(cap1)
```

Time to fetch data with `ca_getvals()`

```{r cap1_lst, cache = TRUE}
cap1_lst <- cap1 %>% ca_getvals(quiet = TRUE)
```

The object returned by `ca_getvals()` is a really nasty list. 99% of the time you'll want to convert the results to a tibble (aka data frame) using `ca_vals2tbl()`. 

Note in the example below we also i) pull out just RCP45, ii) convert degrees to &#176;F using the handy `set_units` function from the `units` package.
  
```{r}
cap1_rcp45_tbl <- cap1_lst %>% ca_vals2tbl(spatial_ag = FALSE) %>%
  filter(scenario == "rcp45") %>%
  mutate(temp_f = set_units(val, degF))

cap1_rcp45_tbl
```

Plot these with ggplot:

```{r ggplot_cap1, cache = TRUE}
ggplot(data = cap1_rcp45_tbl, aes(x = dt, y = as.numeric(temp_f), group = gcm)) +
  geom_line(aes(color=gcm)) +
  labs(title = "Average Annual Maximum Temperature for RCP4.5", x = "year", y = "temp (F)")
```

## Your Turn

Modify the above to create a similar plot for RCP8.5.

```{r}
## Plot of RCP 8.5 goes here

```

# Reshape values into a 'wide' format:

The tibble returned by `ca_vals2df()` is 'long'. Many R packages (including ggplot2) have arguments to 'group' rows together, so long formats are good. However sometimes you need to reshape the data into a 'wide' format. 

This can be done using `pivot_wider` from the `tidyr` package. Here we make each GCM a separate column:

```{r reshape_cap1, cache = TRUE}
cap1_rcp45_wide_tbl <- cap1_rcp45_tbl %>%
  select(id, dt, gcm, temp_f) %>%
  pivot_wider(names_from = gcm, values_from = temp_f)

cap1_rcp45_wide_tbl
```

# Example #2: Retrieve Data for a County

Cal-Adapt API has a number of 'preset' areas of interest you can use cookie-cutter style when retreiving climate data. The advantage of using an AOI Preset is that you don't need to import a GIS layer to query according to these common features. You just need to know the name or ID number of the feature(s) you're interested in.

The following AOI Presets are available:

```{r preset_types, cache = TRUE}
aoipreset_types
```

## Verify the name (or id) of the desired feature(s) in the AOI Preset 

To use an AOI Preset, you need to provide the name(s) or id(s) of the feature(s) you want to query. The specific columns available for identifying features vary by each preset. You can view the columns and values for an AOI Preset using the built-in `aoipreset_idval` constant. For example the counties layer allows you to specify a county by name, fips code, or id. Remember that everything in R is case-sensitive!

```{r idval_counties, cache = TRUE}
aoipreset_idval$counties
```

## Create the API Request

Let's create an API request for Colusa County. 

```{r cap2_define, cache = TRUE}
cap2 <- ca_loc_aoipreset(type="counties", idfld = "name", idval = "Colusa") %>%
  ca_gcm(gcms[1:4]) %>%
  ca_scenario(c("rcp45", "rcp85")) %>%
  ca_period("year") %>%
  ca_years(start = 2030, end = 2080) %>%
  ca_cvar(c("tasmin")) %>%
  ca_options(spatial_ag = "mean")

cap2
```

Note the API request includes the `ca_options()`, which specifies how the pixels within the area of interest should be summarized. This is requried because the location we're querying is a polygon which could include many pixels in the climate data, and we only want one number back.

To double-check the area, as before we can plot the API request: 

```{r plot_cap2, cache = TRUE}
plot(cap2)
```

Then we fetch the data with `ca_getvals()`:

```{r cap2_fetch, cache = TRUE}
cap2_tbl <- cap2 %>% ca_getvals(quiet = TRUE) %>% ca_vals2tbl()
cap2_tbl %>% slice(1:500)
```

Let's plot the difference between rcp85 and rcp45 over time. First we'll convert the temp to degrees Fahrenheit, and split the rcp85 and rcp45 values into separate columns using `pivot_wider`:

```{r cap2_wider, cache = TRUE}
rcp85_minus_rcp45_tbl <- cap2_tbl %>% 
  filter(name == "Colusa") %>% 
  mutate(temp_f = set_units(val, degF)) %>% 
  select(name, gcm, scenario, dt, temp_f) %>% 
  pivot_wider(names_from = scenario, values_from = temp_f)

rcp85_minus_rcp45_tbl
```

Now we're ready to make the plot:

```{r cap2_ggplot, cache = TRUE}
ggplot(data = rcp85_minus_rcp45_tbl, aes(x = dt, y = as.numeric(rcp85 - rcp45), group = gcm)) +
  geom_line(aes(color=gcm)) +
  labs(title = "Difference between RCP8.5 and RCP4.5 in the Annual Minimum \nTemperature for Colusa County", x = "year", y = "temp (F)")
```

# Example #3: Get Daily Data for census Tracts

In this example, we'll grab 5 years of  daily 

## Construct the API Request object:

Get all the census tracks in Imperial county. To make our lives a little easier, we'll identify the census tracts in Imperial using a spatial selection. First grab the boundary of Imperial County:

```{r imperial_cty, cache = TRUE}
counties_imperial_sf  <- ca_aoipreset_geom("counties") %>% filter(name == "Imperial")
plot(counties_imperial_sf %>% st_geometry())
```

Next, import all the census tracts:

```{r census_tracts_all}
tracts_all_sf <- ca_aoipreset_geom("censustracts")
tracts_all_sf %>% slice(1:500)

## Plot census tracts (takes a few seconds):
## plot(tracts_all_sf %>% st_geometry())
```

Find those census tracts in Imperial County:

```{r imperial_tracts}
tract_in_imperial_yn <- st_within(tracts_all_sf, counties_imperial_sf, sparse = FALSE)
table(tract_in_imperial_yn)

tm_shape(tracts_all_sf %>% filter(tract_in_imperial_yn)) +
  tm_polygons() +
tm_shape(counties_imperial_sf) +
  tm_borders(col = "red")
```

Here are the tract ids:

```{r tracts_vals, cache = TRUE}
tracts_vals <- tracts_all_sf$tract[tract_in_imperial_yn]
tracts_vals
```

We put these into the `ca_loc_aoipreset` function in the API request:

```{r cap3_define, cache = TRUE}
cap3 <- ca_loc_aoipreset(type="censustracts", idfld = "tract", idval = tracts_vals) %>%
  ca_gcm("MIROC5") %>%
  ca_scenario(c("rcp85")) %>%
  ca_period("day") %>%
  ca_years(start = "2050-01-01", end = "2055-12-31") %>%
  ca_cvar(c("tasmax")) %>% 
  ca_options(spatial_ag = "max")

cap3

```

Now we're ready to fetch the data:

```{r cap3_fetch, cache = TRUE}
cap3_tbl <- cap3 %>% ca_getvals(quiet = TRUE) %>% ca_vals2tbl()
cap3_tbl %>% slice(1:500)
```
If you wanted to pull out just the values for March and April, you could do something like:

```{r cap3_march_april, cache = TRUE}
cap3_marchapril_tbl <- cap3_tbl %>% 
  mutate(month_num = month(as.Date(dt))) %>% 
  filter(month_num %in% c(3,4)) %>% 
  select(tract, cvar, gcm, scenario, dt, month_num, val)

cap3_marchapril_tbl
```

Select a single tract and add a field for temperature:

```{r cap3_tempf, cache=TRUE}
cap3_degf_tbl <- cap3_tbl %>% 
  filter(tract == 6025010101) %>% 
  mutate(temp_f = set_units(val, degF)) %>% 
  select(tract, cvar, gcm, scenario, dt, temp_f)

cap3_degf_tbl
```

Plot a histogram of values:

```{r cap3_vals_hist, cache=TRUE}
hist(cap3_degf_tbl$temp_f)
```

Identify those days above 110 &#176;F:

```{r cap3_superhot, cache = TRUE}
super_hot_yn <- (cap3_degf_tbl$temp_f > as_units(110, "degF"))
table(super_hot_yn)
```

Count the number of heat spells consisting of **3 or more** consecutive days of >110 &#176;F.

```{r tempruns, cache = TRUE}
## Use rle to chop up the series of TRUE of FALSE into 'runs'
tempruns <- rle(super_hot_yn)
tempruns

## Identify those runs where value is TRUE and thre are 3 or more values in the run 
extreme_heat_runs <- which(tempruns$values & tempruns$lengths >= 3)

length(extreme_heat_runs)
```


