---
title: "Intro and Examples"
output:
  html_notebook:
    df_print: paged
    toc: yes
    toc_float: yes
---

```{css echo = FALSE}
h1 {
  font-weight: bold;
  font-size: 24px;
  color: darkolivegreen;
  border-top: 3px solid dimgrey;
  margin-top: 1em;
  padding-top: 0.5em;
}
h1.title {
  color: black;
  border: none;
}
h2 {
  font-weight: bold;
  font-size: 22px;
  color: dimgray;
}

h3 {
  font-weight: bold;
  font-size: 18px;
  color: black;
}

```

<p style="text-align:right;"><img src="https://ucanr-igis.github.io/caladaptr/reference/figures/caladaptr-beta_logo.svg" width="240" /></p>

# About this R Notebook

R Notebooks are a 'flavor' of R markdown that combine plain text and R commands in code chunks. (You can download the Rmd file from the 'code' button at the top of the page.) You run code chunks in the document line-by-line, and the output appears immediately below the code chunk.

If you're in RStudio, you can *minimize the console window* (and probably close the right-hand panes as well). You won't need it,  because when you run R commands in a R Notebook the *output appears below the code chunk* (not the console). This takes some getting used to.

Keyboard shortcuts:  
- run the current line of R: *ctrl + enter*  
- run everything in the current code chunk: *ctrl + shift + enter*  
- insert a new code chunk: *ctrl + alt + i*  

# Setup

The following commands will install any packages you don't already have that will be needed below:

```{r load_pkgs, cache = TRUE}
pkgs_req <- c("remotes", "ggplot2", "dplyr", "tmap", "conflicted", "leaflet", "tidyr")
pkgs_missing <- pkgs_req[!(pkgs_req %in% installed.packages()[,"Package"])]
if (length(pkgs_missing)) install.packages(pkgs_missing, dependencies=TRUE)
```

Install caladaptr:

```{r}
# remotes::install_github("ucanr-igis/caladaptr")
```

Now we can load all the required libraries:

```{r library_all}
library(caladaptr, quietly = TRUE)
library(units, quietly = TRUE)
library(ggplot2, quietly = TRUE)
library(dplyr, quietly = TRUE)
library(conflicted, quietly = TRUE)
library(tidyr, quietly = TRUE)
library(tmap, quietly = TRUE)
library(lubridate, quietly = TRUE)
library(sf, quietly = TRUE)
```

The last setup task is to define your preferences when you're forced to use an ambiguous function name (i.e., a function that exists in more than one package). This is particularly needed with a few common generic functions from `dplyr`:

```{r set_conflicts}
conflict_prefer("filter", "dplyr", quiet = TRUE)
conflict_prefer("count", "dplyr", quiet = TRUE)
conflict_prefer("select", "dplyr", quiet = TRUE)
```

# Example #1: Get Projected Temperature for a Point

## Create the Cal-Adapt API Request

The first step in getting climate variables back is to create the Cal-Adapt API request object. This involves stringing together a series of functions together that specify the pieces of the request. The following constants can help you specify pieces of the request:

```{r view_constants, cache = TRUE}
## Available global change models
gcms

## Available emissions scenarios
scenarios

## Available climate variables
climvars

## Available temporal aggregation periods
periods
```
**Note**: Cal-Adapt has data for many but by no means all combinations of the above constants.

You can use these values as arguments to build up the API request:

```{r}
cap1 <- ca_loc_pt(coords = c(-121.4687, 38.5938)) %>%
  ca_gcm(gcms[1:4]) %>%
  ca_scenario(c("rcp45", "rcp85")) %>%
  ca_period("year") %>%
  ca_years(start = 2030, end = 2080) %>%
  ca_cvar(c("tasmax"))

cap1
```
To verify the location in an API request, you can plot it. (Note we still haven't fetched any climate data yet, this just shows you the location the request will ask for.)

```{r plot_cap1}
plot(cap1)
```

Time to fetch data with `ca_getvals()`

```{r cap1_lst, cache = TRUE}
cap1_lst <- cap1 %>% ca_getvals(quiet = TRUE)
```

The object returned by `ca_getvals()` is a really nasty list. 99% of the time you'll want to convert the results to a tibble (aka data frame) using `ca_vals2tbl()`. 

Note in the example below we also i) pull out just RCP45, ii) convert degrees to &#176;F using the handy `set_units` function from the `units` package.
  
```{r}
cap1_rcp45_tbl <- cap1_lst %>% ca_vals2tbl(spatial_ag = FALSE) %>%
  filter(scenario == "rcp45") %>%
  mutate(temp_f = set_units(val, degF))

dim(cap1_rcp45_tbl)
head(cap1_rcp45_tbl)
```

Plot these with ggplot:

```{r ggplot_cap1, cache = TRUE}
ggplot(data = cap1_rcp45_tbl, aes(x = dt, y = as.numeric(temp_f), group = gcm)) +
  geom_line(aes(color=gcm)) +
  labs(title = "Average Annual Maximum Temperature for RCP4.5", x = "year", y = "temp (F)")
```

## Your Turn

Modify the above to create a similar plot for RCP8.5.

```{r}
## Plot of RCP 8.5 goes here

```

# Reshape values into a 'wide' format:

The tibble returned by `ca_vals2df()` is 'long'. Many R packages (including ggplot2) have arguments to 'group' rows together, so long formats are good. However sometimes you need to reshape the data into a 'wide' format. 

This can be done using `pivot_wider` from the `tidyr` package. Here we make each GCM a separate column:

```{r reshape_cap1, cache = TRUE}
cap1_rcp45_wide_tbl <- cap1_rcp45_tbl %>%
  select(id, dt, gcm, temp_f) %>%
  pivot_wider(names_from = gcm, values_from = temp_f)

cap1_rcp45_wide_tbl
```

# Example #2: Retrieve Data for a County

Cal-Adapt API has a number of 'preset' areas of interest you can use cookie-cutter style when retreiving climate data. The advantage of using an AOI Preset is that you don't need to import a GIS layer to query according to these common features. You just need to know the name or ID number of the feature(s) you're interested in.

The following AOI Presets are available:

```{r preset_types, cache = TRUE}
aoipreset_types
```

## Verify the name (or id) of the desired feature(s) in the AOI Preset 

To use an AOI Preset, you need to provide the name(s) or id(s) of the feature(s) you want to query. The specific columns available for identifying features vary by each preset. You can view the columns and values for an AOI Preset using the built-in `aoipreset_idval` constant. For example the counties layer allows you to specify a county by name, fips code, or id. Remember that everything in R is case-sensitive!

```{r idval_counties, cache = TRUE}
aoipreset_idval$counties
```

## Create the API Request

Let's create an API request for Colusa County. 

```{r cap2_define, cache = TRUE}
cap2 <- ca_loc_aoipreset(type="counties", idfld = "name", idval = "Colusa") %>%
  ca_gcm(gcms[1:4]) %>%
  ca_scenario(c("rcp45", "rcp85")) %>%
  ca_period("year") %>%
  ca_years(start = 2030, end = 2080) %>%
  ca_cvar(c("tasmin")) %>%
  ca_options(spatial_ag = "mean")

cap2
```

Note the API request includes the `ca_options()`, which specifies how the pixels within the area of interest should be summarized. This is requried because the location we're querying is a polygon which could include many pixels in the climate data, and we only want one number back.

To double-check the area, as before we can plot the API request: 

```{r plot_cap2, cache = TRUE}
plot(cap2)
```

Then we fetch the data with `ca_getvals()`:

```{r cap2_fetch, cache = TRUE}
cap2_tbl <- cap2 %>% ca_getvals(quiet = TRUE) %>% ca_vals2tbl()

dim(cap2_tbl)
head(cap2_tbl)
```

Let's plot the difference between rcp85 and rcp45 over time. First we'll convert the temp to degrees Fahrenheit, and split the rcp85 and rcp45 values into separate columns using `pivot_wider`:

```{r cap2_wider, cache = TRUE}
rcp85_minus_rcp45_tbl <- cap2_tbl %>% 
  filter(name == "Colusa") %>% 
  mutate(temp_f = set_units(val, degF)) %>% 
  select(name, gcm, scenario, dt, temp_f) %>% 
  pivot_wider(names_from = scenario, values_from = temp_f)

dim(rcp85_minus_rcp45_tbl)
head(rcp85_minus_rcp45_tbl)
```

Now we're ready to make the plot:

```{r cap2_ggplot, cache = TRUE}
ggplot(data = rcp85_minus_rcp45_tbl, aes(x = dt, y = as.numeric(rcp85 - rcp45), group = gcm)) +
  geom_line(aes(color=gcm)) +
  labs(title = "Difference between RCP8.5 and RCP4.5 in the Annual Minimum \nTemperature for Colusa County", x = "year", y = "temp (F)")
```

# Example #3: Get Daily Data for census Tracts

In this example, we'll grab 5 years of  daily temperature data for census tracts that fall within Imperial County. We'll then select one of the census tracts and count the number of extreme heat events in the 5-year time span, using a definition of extreme heat event as a number of consecutive days where the maximum temperature exceeds a threshhold.

## Construct the API Request object:

Get all the census tracks in Imperial county. To make our lives a little easier, we'll identify the census tracts in Imperial using a spatial selection. First grab the boundary of Imperial County:

```{r imperial_cty, cache = TRUE}
counties_imperial_sf  <- ca_aoipreset_geom("counties") %>% filter(name == "Imperial")
plot(counties_imperial_sf %>% st_geometry())
```

Next, import all the census tracts:

```{r census_tracts_all}
tracts_all_sf <- ca_aoipreset_geom("censustracts")
tracts_all_sf

## Plot census tracts (takes a few seconds):
## plot(tracts_all_sf %>% st_geometry())
```

Identify those census tracts within Imperial County using `st_within`:

```{r imperial_tracts}
tract_in_imperial_yn <- st_within(tracts_all_sf, counties_imperial_sf, sparse = FALSE)
table(tract_in_imperial_yn)

tm_shape(tracts_all_sf %>% filter(tract_in_imperial_yn)) +
  tm_polygons() +
tm_shape(counties_imperial_sf) +
  tm_borders(col = "red")
```

We can now pull out the tract 'names' (to feed into the API call):

```{r tracts_vals, cache = TRUE}
tracts_vals <- tracts_all_sf$tract[tract_in_imperial_yn]
tracts_vals
```

We put these into the `ca_loc_aoipreset` function in the API request:

```{r cap3_define, cache = TRUE}
cap3 <- ca_loc_aoipreset(type="censustracts", idfld = "tract", idval = tracts_vals) %>%
  ca_gcm("MIROC5") %>%
  ca_scenario(c("rcp45", "rcp85")) %>%
  ca_period("day") %>%
  ca_years(start = "2050-01-01", end = "2055-12-31") %>%
  ca_cvar(c("tasmax")) %>% 
  ca_options(spatial_ag = "max")

cap3

```

Now we're ready to fetch the data:

```{r cap3_fetch, cache = TRUE}
cap3_tbl <- cap3 %>% ca_getvals(quiet = TRUE) %>% ca_vals2tbl()

dim(cap3_tbl)
head(cap3_tbl)
```
### Aside: Subset by Month

If you wanted to pull out just the values for March and April, you could do something like:

```{r cap3_march_april, cache = TRUE}
cap3_marchapril_tbl <- cap3_tbl %>% 
  mutate(month_num = month(as.Date(dt))) %>% 
  filter(month_num %in% c(3,4)) %>% 
  select(tract, cvar, gcm, scenario, dt, month_num, val)

cap3_marchapril_tbl
```

## Extreme heat analysis of a single tract

In this section, we'll select a single census tract and count the number of extreme heat events during this five-year period. We'll define an extreme heat event to be 3 or more consecutive days where the maximum temperature is >110 &#176;F.

First, select a single tract and add a field for temperature in &#176;F:

```{r cap3_tempf, cache=TRUE}
cap3_degf_tbl <- cap3_tbl %>% 
  filter(tract == 6025010101) %>% 
  mutate(temp_f = set_units(val, degF)) %>% 
  select(tract, cvar, gcm, scenario, dt, temp_f)

dim(cap3_degf_tbl)
head(cap3_degf_tbl)
```

Plot a histogram of values for each rcp:

```{r cap3_vals_hist1, cache=TRUE}
hist(cap3_degf_tbl %>%  filter(scenario == "rcp45") %>% pull(temp_f),
     main = "Maximum Daily Temp, 2050-2055 \n RCP4.5",
     xlab = "temp (F)") 

hist(cap3_degf_tbl %>%  filter(scenario == "rcp85") %>% pull(temp_f),
     main = "Maximum Daily Temp, 2050-2055 \n RCP8.5",
     xlab = "temp (F)") 

```

For RCP4.5, identify those days above 110 &#176;F:

```{r cap3_superhot, cache = TRUE}
super_hot_yn <- (cap3_degf_tbl %>% 
                   filter(scenario == "rcp45") %>% 
                   pull(temp_f) > as_units(110, "degF"))
table(super_hot_yn)
```

Count the number of heat spells consisting of **3 or more** consecutive days of >110 &#176;F.

```{r tempruns, cache = TRUE}
## Use rle to chop up the series of TRUE of FALSE into 'runs'
tempruns <- rle(super_hot_yn)
tempruns

## Identify those runs where value is TRUE and thre are 3 or more values in the run 
extreme_heat_runs <- which(tempruns$values & tempruns$lengths >= 3)

length(extreme_heat_runs)
```

==> Under RCP4.5, the MIROC5 model predicts this census tract will experience 34 extreme heat events (defined as 3 or more days above 110 &#176;F) during the 5 year period in question.

## YOUR TURN: How many extreme heat events will there be under RCP8.5?

```{r}
## Your answer goes here:
```


Ans. 42

